<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Moshier WASM Advanced Browser Tests</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 20px;
        background-color: #f5f5f5;
      }
      .test-container {
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      .test-result {
        margin: 10px 0;
        padding: 10px;
        border-radius: 4px;
      }
      .test-pass {
        background-color: #d4edda;
        border: 1px solid #c3e6cb;
        color: #155724;
      }
      .test-fail {
        background-color: #f8d7da;
        border: 1px solid #f5c6cb;
        color: #721c24;
      }
      .test-running {
        background-color: #fff3cd;
        border: 1px solid #ffeaa7;
        color: #856404;
      }
      .summary {
        margin-top: 20px;
        padding: 15px;
        background-color: #e9ecef;
        border-radius: 4px;
        font-weight: bold;
      }
      .performance-metrics {
        background-color: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 4px;
        padding: 10px;
        margin: 10px 0;
      }
      .calculation-result {
        background-color: #e7f3ff;
        border: 1px solid #b3d9ff;
        border-radius: 4px;
        padding: 10px;
        margin: 10px 0;
        font-family: monospace;
        white-space: pre-wrap;
        max-height: 200px;
        overflow-y: auto;
      }
    </style>
  </head>
  <body>
    <div class="test-container">
      <h1>Moshier WASM Advanced Browser Tests</h1>
      <div id="test-output"></div>
      <div id="performance-metrics"></div>
      <div id="summary" class="summary"></div>
    </div>

    <script>
      // Advanced test framework with performance monitoring
      class AdvancedBrowserTestFramework {
        constructor() {
          this.tests = [];
          this.results = {
            total: 0,
            passed: 0,
            failed: 0,
            failures: [],
            completed: false,
            performance: {},
          };
          this.testOutput = document.getElementById("test-output");
          this.summaryElement = document.getElementById("summary");
          this.performanceElement = document.getElementById("performance-metrics");
        }

        test(name, testFunction) {
          this.tests.push({ name, testFunction });
        }

        async runTests() {
          console.log("Starting advanced browser tests...");
          this.results.total = this.tests.length;

          for (const test of this.tests) {
            await this.runTest(test);
          }

          this.results.completed = true;
          this.updateSummary();
          this.updatePerformanceMetrics();
          console.log("All advanced tests completed:", this.results);
        }

        async runTest(test) {
          const testElement = this.createTestElement(test.name);
          const startTime = performance.now();

          try {
            const result = await test.testFunction();
            const endTime = performance.now();
            const duration = endTime - startTime;

            this.results.passed++;
            this.results.performance[test.name] = { duration, success: true };

            testElement.className = "test-result test-pass";
            testElement.textContent = `✅ ${test.name} (${duration.toFixed(2)}ms)`;

            // Add result details if available
            if (result && result.details) {
              const detailsElement = document.createElement("div");
              detailsElement.className = "calculation-result";
              detailsElement.textContent = result.details;
              testElement.appendChild(detailsElement);
            }

            console.log(`✅ ${test.name} - PASSED (${duration.toFixed(2)}ms)`);
          } catch (error) {
            const endTime = performance.now();
            const duration = endTime - startTime;

            this.results.failed++;
            this.results.performance[test.name] = { duration, success: false };
            this.results.failures.push({
              name: test.name,
              error: error.message,
            });

            testElement.className = "test-result test-fail";
            testElement.textContent = `❌ ${test.name} - ${
              error.message
            } (${duration.toFixed(2)}ms)`;
            console.error(`❌ ${test.name} - FAILED:`, error);
          }
        }

        createTestElement(testName) {
          const element = document.createElement("div");
          element.className = "test-result test-running";
          element.textContent = `⏳ ${testName} - Running...`;
          this.testOutput.appendChild(element);
          return element;
        }

        updateSummary() {
          this.summaryElement.textContent = `Tests: ${this.results.passed}/${this.results.total} passed, ${this.results.failed} failed`;
        }

        updatePerformanceMetrics() {
          const metrics = this.results.performance;
          const totalDuration = Object.values(metrics).reduce(
            (sum, metric) => sum + metric.duration,
            0
          );
          const avgDuration = totalDuration / Object.keys(metrics).length;

          let metricsHtml = "<h3>Performance Metrics</h3>";
          metricsHtml += `<div class="performance-metrics">`;
          metricsHtml += `<strong>Total Duration:</strong> ${totalDuration.toFixed(
            2
          )}ms<br>`;
          metricsHtml += `<strong>Average Duration:</strong> ${avgDuration.toFixed(
            2
          )}ms<br>`;
          metricsHtml += `<strong>Tests per Second:</strong> ${(
            1000 / avgDuration
          ).toFixed(2)}<br>`;
          metricsHtml += "</div>";

          this.performanceElement.innerHTML = metricsHtml;
        }

        // Helper method to create a worker and wait for response
        createWorkerAndWait(workerScript, testData, timeout = 15000) {
          return new Promise((resolve, reject) => {
            const worker = new Worker(workerScript);
            const startTime = performance.now();

            const timeoutId = setTimeout(() => {
              worker.terminate();
              reject(new Error(`Worker timeout after ${timeout}ms`));
            }, timeout);

            worker.onmessage = (event) => {
              const endTime = performance.now();
              clearTimeout(timeoutId);
              worker.terminate();

              resolve({
                data: event.data,
                duration: endTime - startTime,
              });
            };

            worker.onerror = (error) => {
              clearTimeout(timeoutId);
              worker.terminate();
              reject(new Error(`Worker error: ${error.message}`));
            };

            worker.postMessage(testData);
          });
        }
      }

      // Create test framework instance
      const testFramework = new AdvancedBrowserTestFramework();

      // Test: Validate Astrological Calculation Structure
      testFramework.test("Validate Calculation Result Structure", async () => {
        const testData = [2024, 1, 15, 14, 30, 0, 74, 0, 0, "W", 40, 42, 51, "N", "P"];

        const result = await testFramework.createWorkerAndWait(
          "../js/sweph.js",
          testData
        );

        // Validate the result structure
        if (!result.data || typeof result.data !== "string") {
          throw new Error("Result is not a string");
        }

        if (result.data.length === 0) {
          throw new Error("Result is empty");
        }

        // Check if result contains expected astrological data patterns
        const hasPlanets =
          /Sun|Moon|Mercury|Venus|Mars|Jupiter|Saturn|Uranus|Neptune|Pluto/i.test(
            result.data
          );
        const hasHouses = /House|Ascendant|MC|IC|Descendant/i.test(result.data);
        const hasCoordinates = /\d+°\s*\d+'/i.test(result.data);

        if (!hasPlanets && !hasHouses && !hasCoordinates) {
          throw new Error(
            "Result does not contain expected astrological data patterns"
          );
        }

        return {
          details: `Result length: ${
            result.data.length
          } characters\nContains planets: ${hasPlanets}\nContains houses: ${hasHouses}\nContains coordinates: ${hasCoordinates}\nFirst 200 chars: ${result.data.substring(
            0,
            200
          )}...`,
        };
      });

      // Test: Compare Different House Systems
      testFramework.test("Compare Different House Systems", async () => {
        const houseSystems = ["P", "K", "R", "C", "E"];
        const baseData = [2024, 1, 15, 12, 0, 0, 0, 0, 0, "E", 0, 0, 0, "N"];
        const results = {};

        for (const system of houseSystems) {
          const testData = [...baseData, system];
          const result = await testFramework.createWorkerAndWait(
            "../js/sweph.js",
            testData
          );
          results[system] = result.data;
        }

        // Verify that different house systems produce different results
        const uniqueResults = new Set(Object.values(results));
        if (uniqueResults.size < 2) {
          throw new Error("All house systems produced identical results");
        }

        let details = "House System Results Comparison:\n";
        for (const [system, result] of Object.entries(results)) {
          details += `${system}: ${result.substring(0, 100)}...\n`;
        }

        return { details };
      });

      // Test: Performance Benchmark - Multiple Calculations
      testFramework.test("Performance Benchmark - 10 Calculations", async () => {
        const calculations = [];
        const testData = [2024, 1, 15, 12, 0, 0, 0, 0, 0, "E", 0, 0, 0, "N", "P"];

        for (let i = 0; i < 10; i++) {
          const startTime = performance.now();
          const result = await testFramework.createWorkerAndWait(
            "../js/sweph.js",
            testData
          );
          const endTime = performance.now();
          calculations.push({
            duration: endTime - startTime,
            result: result.data,
          });
        }

        const durations = calculations.map((c) => c.duration);
        const avgDuration = durations.reduce((sum, d) => sum + d, 0) / durations.length;
        const minDuration = Math.min(...durations);
        const maxDuration = Math.max(...durations);

        if (avgDuration > 5000) {
          // 5 seconds average
          throw new Error(
            `Average calculation time too slow: ${avgDuration.toFixed(2)}ms`
          );
        }

        return {
          details: `Performance Results:\nAverage: ${avgDuration.toFixed(
            2
          )}ms\nMin: ${minDuration.toFixed(2)}ms\nMax: ${maxDuration.toFixed(
            2
          )}ms\nAll calculations completed successfully.`,
        };
      });

      // Test: Geographic Accuracy - Known Coordinates
      testFramework.test("Geographic Accuracy - Known Coordinates", async () => {
        const testCases = [
          {
            name: "New York City",
            data: [2024, 1, 15, 14, 30, 0, 74, 0, 0, "W", 40, 42, 51, "N", "P"],
            expectedPatterns: ["New York", "NYC", "40°42'51\"N", "74°0'0\"W"],
          },
          {
            name: "London",
            data: [2024, 1, 15, 19, 30, 0, 0, 7, 39, "W", 51, 30, 26, "N", "K"],
            expectedPatterns: ["London", "51°30'26\"N", "0°7'39\"W"],
          },
        ];

        let details = "Geographic Accuracy Test:\n";

        for (const testCase of testCases) {
          const result = await testFramework.createWorkerAndWait(
            "../js/sweph.js",
            testCase.data
          );
          details += `${testCase.name}: ${result.data.substring(0, 150)}...\n`;

          // Check if result contains coordinate information (JSON format)
          const hasCoordinates =
            result.data &&
            typeof result.data === "string" &&
            (result.data.includes('"long":') || result.data.includes('"long_s":'));
          if (!hasCoordinates) {
            throw new Error(
              `${testCase.name} result does not contain coordinate information`
            );
          }
        }

        return { details };
      });

      // Test: Date Range Validation
      testFramework.test("Date Range Validation", async () => {
        const dateRanges = [
          {
            name: "Recent Date",
            data: [2024, 1, 15, 12, 0, 0, 0, 0, 0, "E", 0, 0, 0, "N", "P"],
          },
          {
            name: "Historical Date",
            data: [1900, 12, 31, 23, 59, 0, 0, 0, 0, "E", 0, 0, 0, "N", "P"],
          },
          {
            name: "Future Date",
            data: [2050, 6, 15, 6, 30, 0, 0, 0, 0, "E", 0, 0, 0, "N", "P"],
          },
        ];

        let details = "Date Range Validation:\n";

        for (const testCase of dateRanges) {
          const result = await testFramework.createWorkerAndWait(
            "../js/sweph.js",
            testCase.data
          );
          details += `${testCase.name}: ${result.data.substring(0, 100)}...\n`;

          if (!result.data || result.data.length === 0) {
            throw new Error(`${testCase.name} failed to produce a result`);
          }
        }

        return { details };
      });

      // Test: Error Recovery and Graceful Degradation
      testFramework.test("Error Recovery and Graceful Degradation", async () => {
        const invalidTestCases = [
          { name: "Empty Data", data: [] },
          { name: "Incomplete Data", data: [2024, 1, 15] },
          {
            name: "Invalid Coordinates",
            data: [2024, 1, 15, 12, 0, 0, 200, 0, 0, "X", 100, 0, 0, "Y", "P"],
          },
          {
            name: "Invalid House System",
            data: [2024, 1, 15, 12, 0, 0, 0, 0, 0, "E", 0, 0, 0, "N", "INVALID"],
          },
        ];

        let details = "Error Recovery Test:\n";
        let allHandledGracefully = true;

        for (const testCase of invalidTestCases) {
          try {
            const result = await testFramework.createWorkerAndWait(
              "../js/sweph.js",
              testCase.data,
              5000
            );
            details += `${testCase.name}: Handled gracefully (${
              result.data ? "has result" : "no result"
            })\n`;
          } catch (error) {
            details += `${testCase.name}: Error caught - ${error.message}\n`;
            // Errors are expected for invalid data, so we don't fail the test
          }
        }

        return { details };
      });

      // Test: Memory Usage and Resource Cleanup
      testFramework.test("Memory Usage and Resource Cleanup", async () => {
        const iterations = 5;
        const testData = [2024, 1, 15, 12, 0, 0, 0, 0, 0, "E", 0, 0, 0, "N", "P"];

        let details = "Memory Usage Test:\n";

        for (let i = 0; i < iterations; i++) {
          const startMemory = performance.memory
            ? performance.memory.usedJSHeapSize
            : 0;
          const result = await testFramework.createWorkerAndWait(
            "../js/sweph.js",
            testData
          );
          const endMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;

          details += `Iteration ${i + 1}: Memory delta ${(
            (endMemory - startMemory) /
            1024
          ).toFixed(2)}KB\n`;

          // Force garbage collection if available
          if (window.gc) {
            window.gc();
          }
        }

        return { details };
      });

      // Expose test results globally for the test runner
      window.testResults = testFramework.results;

      // Run all tests when page loads
      window.addEventListener("load", () => {
        testFramework.runTests();
      });
    </script>
  </body>
</html>
